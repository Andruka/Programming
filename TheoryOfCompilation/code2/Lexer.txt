------------
Ќе очень хорошо выбран тип разделителей и операторов, что не позвол€ет 
использовать несколько символов:
// /* */ \r\n == <= >=  и др.
“.к. всЄ равно используетс€ ф-ци€ поиска в строке под строки, то почему бы
не использовать разделители в строке, например ";":
1.
    if(_Deviders.find(";" + token.Text() + ";")!=_Deviders.npos)
2.
    _Deviders = ";";
    for(unsigned i=0;i<dvc;++i)
        _Deviders += fnend[i] + ";";

этот вариант не намного лучше варианта vector<...>


------------
’орошо бы внести поддержку однострочных и многострочных коментариев


------------
Ќа момент отладки не плохо бы считать координаты токена (колонка и строка)
ѕроще будет глюки выгребать


------------
SkanStringConstant
конец строки внутри кавычек (не "\r\n") разве не €вл€етс€ ошибкой?
в принципе можно оставить и так, но нужно описать в доках.


------------
SkipSpacing
’орошо бы провер€ть не только пробелы, но и табы "\t", а так-же конец строки 
"\r\n"
“.е.:

void CLexer::SkipSpacing(const string& text)
{
    if(!strchr(" \t\r\n", text[_OffSet])//если текуща€ позици€ не 
заполнитель
        return;//то пропускать то и нечего

    while(strchr(" \t\r\n", text[_OffSet]) _OffSet++;
    _OffSet--;
}


------------
SaveTokens
ј тут ты зр€ использовал
	string str;
, лучше использовать
	const char* str;
так хоть лишнего копировани€ не будет.

ј еще лучше использовать массив вместо switch
что быстрее куча if'ов или двойной сдвиг в лево (<<2) (1 команда процессора) 
или умножение на 4


